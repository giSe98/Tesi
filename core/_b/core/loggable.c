/* loggable.c generated by valac 0.40.23, the Vala compiler
 * generated from loggable.vala, do not modify */

/*
 Copyright (C) 2018 Christian Dywan <christian@twotoats.de>

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 See the file COPYING for the full license text.
*/


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

typedef enum  {
	MIDORI_DEBUG_FLAGS_NONE,
	MIDORI_DEBUG_FLAGS_HISTORY
} MidoriDebugFlags;


#define MIDORI_TYPE_DEBUG_FLAGS (midori_debug_flags_get_type ())

#define MIDORI_TYPE_LOGGABLE (midori_loggable_get_type ())
#define MIDORI_LOGGABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MIDORI_TYPE_LOGGABLE, MidoriLoggable))
#define MIDORI_IS_LOGGABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MIDORI_TYPE_LOGGABLE))
#define MIDORI_LOGGABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MIDORI_TYPE_LOGGABLE, MidoriLoggableIface))

typedef struct _MidoriLoggable MidoriLoggable;
typedef struct _MidoriLoggableIface MidoriLoggableIface;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _MidoriLoggableIface {
	GTypeInterface parent_iface;
};



GType midori_debug_flags_get_type (void) G_GNUC_CONST;
GType midori_loggable_get_type (void) G_GNUC_CONST;
void midori_loggable_debug (MidoriLoggable* self,
                            const gchar* format,
                            ...);
gchar* midori_loggable_get_domain (MidoriLoggable* self);
gboolean midori_loggable_get_logging (MidoriLoggable* self);
static gboolean* _bool_dup (gboolean* self);

const GDebugKey MIDORI_keys[1] = {{"historydatabase", (guint) MIDORI_DEBUG_FLAGS_HISTORY}};

GType
midori_debug_flags_get_type (void)
{
	static volatile gsize midori_debug_flags_type_id__volatile = 0;
	if (g_once_init_enter (&midori_debug_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{MIDORI_DEBUG_FLAGS_NONE, "MIDORI_DEBUG_FLAGS_NONE", "none"}, {MIDORI_DEBUG_FLAGS_HISTORY, "MIDORI_DEBUG_FLAGS_HISTORY", "history"}, {0, NULL, NULL}};
		GType midori_debug_flags_type_id;
		midori_debug_flags_type_id = g_enum_register_static ("MidoriDebugFlags", values);
		g_once_init_leave (&midori_debug_flags_type_id__volatile, midori_debug_flags_type_id);
	}
	return midori_debug_flags_type_id__volatile;
}


void
midori_loggable_debug (MidoriLoggable* self,
                       const gchar* format,
                       ...)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	va_list _tmp3_ = {0};
#line 49 "/home/test/core/core/loggable.vala"
	g_return_if_fail (format != NULL);
#line 50 "/home/test/core/core/loggable.vala"
	_tmp0_ = midori_loggable_get_domain (self);
#line 50 "/home/test/core/core/loggable.vala"
	_tmp1_ = _tmp0_;
#line 50 "/home/test/core/core/loggable.vala"
	_tmp2_ = _tmp1_;
#line 50 "/home/test/core/core/loggable.vala"
	va_start (_tmp3_, format);
#line 50 "/home/test/core/core/loggable.vala"
	g_logv (_tmp2_, G_LOG_LEVEL_DEBUG, format, _tmp3_);
#line 50 "/home/test/core/core/loggable.vala"
	va_end (_tmp3_);
#line 50 "/home/test/core/core/loggable.vala"
	_g_free0 (_tmp2_);
#line 96 "loggable.c"
}


static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
#line 1392 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
#line 1392 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	end = _tmp0_;
#line 1393 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	_tmp1_ = end;
#line 1393 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	if (_tmp1_ == NULL) {
#line 1394 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		result = maxlen;
#line 1394 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		return result;
#line 120 "loggable.c"
	} else {
		gchar* _tmp2_;
#line 1396 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp2_ = end;
#line 1396 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		result = (glong) (_tmp2_ - str);
#line 1396 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		return result;
#line 129 "loggable.c"
	}
}


static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp6_;
	gchar* _tmp7_;
#line 1403 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, NULL);
#line 1405 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	if (offset >= ((glong) 0)) {
#line 1405 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp0_ = len >= ((glong) 0);
#line 150 "loggable.c"
	} else {
#line 1405 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp0_ = FALSE;
#line 154 "loggable.c"
	}
#line 1405 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	if (_tmp0_) {
#line 1407 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		string_length = string_strnlen ((gchar*) self, offset + len);
#line 160 "loggable.c"
	} else {
		gint _tmp1_;
		gint _tmp2_;
#line 1409 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp1_ = strlen (self);
#line 1409 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp2_ = _tmp1_;
#line 1409 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		string_length = (glong) _tmp2_;
#line 170 "loggable.c"
	}
#line 1412 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	if (offset < ((glong) 0)) {
#line 174 "loggable.c"
		glong _tmp3_;
#line 1413 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp3_ = string_length;
#line 1413 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		offset = _tmp3_ + offset;
#line 1414 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
#line 182 "loggable.c"
	} else {
		glong _tmp4_;
#line 1416 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp4_ = string_length;
#line 1416 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		g_return_val_if_fail (offset <= _tmp4_, NULL);
#line 189 "loggable.c"
	}
#line 1418 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	if (len < ((glong) 0)) {
#line 193 "loggable.c"
		glong _tmp5_;
#line 1419 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		_tmp5_ = string_length;
#line 1419 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
		len = _tmp5_ - offset;
#line 199 "loggable.c"
	}
#line 1421 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	_tmp6_ = string_length;
#line 1421 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	g_return_val_if_fail ((offset + len) <= _tmp6_, NULL);
#line 1422 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	_tmp7_ = g_strndup (((gchar*) self) + offset, (gsize) len);
#line 1422 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	result = _tmp7_;
#line 1422 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	return result;
#line 211 "loggable.c"
}


gchar*
midori_loggable_get_domain (MidoriLoggable* self)
{
	gchar* result;
	gchar* _domain = NULL;
	gconstpointer _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
#line 23 "/home/test/core/core/loggable.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 24 "/home/test/core/core/loggable.vala"
	_tmp0_ = g_object_get_data ((GObject*) self, "midori-domain");
#line 24 "/home/test/core/core/loggable.vala"
	_tmp1_ = g_strdup ((const gchar*) _tmp0_);
#line 24 "/home/test/core/core/loggable.vala"
	_domain = _tmp1_;
#line 25 "/home/test/core/core/loggable.vala"
	_tmp2_ = _domain;
#line 25 "/home/test/core/core/loggable.vala"
	if (_tmp2_ == NULL) {
#line 235 "loggable.c"
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
#line 26 "/home/test/core/core/loggable.vala"
		_tmp3_ = g_type_name (G_TYPE_FROM_INSTANCE ((GObject*) self));
#line 26 "/home/test/core/core/loggable.vala"
		_tmp4_ = string_substring (_tmp3_, (glong) 6, (glong) -1);
#line 26 "/home/test/core/core/loggable.vala"
		_tmp5_ = _tmp4_;
#line 26 "/home/test/core/core/loggable.vala"
		_tmp6_ = g_utf8_strdown (_tmp5_, (gssize) -1);
#line 26 "/home/test/core/core/loggable.vala"
		_g_free0 (_domain);
#line 26 "/home/test/core/core/loggable.vala"
		_domain = _tmp6_;
#line 26 "/home/test/core/core/loggable.vala"
		_g_free0 (_tmp5_);
#line 27 "/home/test/core/core/loggable.vala"
		_tmp7_ = _domain;
#line 27 "/home/test/core/core/loggable.vala"
		_tmp8_ = g_strdup (_tmp7_);
#line 27 "/home/test/core/core/loggable.vala"
		g_object_set_data_full ((GObject*) self, "midori-domain", _tmp8_, g_free);
#line 262 "loggable.c"
	}
#line 29 "/home/test/core/core/loggable.vala"
	result = _domain;
#line 29 "/home/test/core/core/loggable.vala"
	return result;
#line 268 "loggable.c"
}


static gboolean*
_bool_dup (gboolean* self)
{
	gboolean* dup;
#line 33 "/home/test/core/core/loggable.vala"
	dup = g_new0 (gboolean, 1);
#line 33 "/home/test/core/core/loggable.vala"
	memcpy (dup, self, sizeof (gboolean));
#line 33 "/home/test/core/core/loggable.vala"
	return dup;
#line 282 "loggable.c"
}


static gpointer
__bool_dup0 (gpointer self)
{
#line 33 "/home/test/core/core/loggable.vala"
	return self ? _bool_dup (self) : NULL;
#line 291 "loggable.c"
}


gboolean
midori_loggable_get_logging (MidoriLoggable* self)
{
	gboolean result;
	gboolean* _logging = NULL;
	gconstpointer _tmp0_;
	gboolean* _tmp1_;
	gboolean* _tmp2_;
	gboolean* _tmp20_;
	gboolean _tmp21_;
#line 32 "/home/test/core/core/loggable.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 33 "/home/test/core/core/loggable.vala"
	_tmp0_ = g_object_get_data ((GObject*) self, "midori-logging");
#line 33 "/home/test/core/core/loggable.vala"
	_tmp1_ = __bool_dup0 ((gboolean*) _tmp0_);
#line 33 "/home/test/core/core/loggable.vala"
	_logging = _tmp1_;
#line 34 "/home/test/core/core/loggable.vala"
	_tmp2_ = _logging;
#line 34 "/home/test/core/core/loggable.vala"
	if (_tmp2_ == NULL) {
#line 317 "loggable.c"
		guint flag = 0U;
		gchar* debug_string = NULL;
		const gchar* _tmp11_;
		gchar* _tmp12_;
		guint flags = 0U;
		const gchar* _tmp13_;
		guint _tmp14_;
		guint _tmp15_;
		gboolean _tmp16_;
		gboolean* _tmp17_;
		gboolean* _tmp18_;
		gboolean* _tmp19_;
#line 35 "/home/test/core/core/loggable.vala"
		flag = (guint) G_MAXINT;
#line 332 "loggable.c"
		{
			GDebugKey* key_collection = NULL;
			gint key_collection_length1 = 0;
			gint _key_collection_size_ = 0;
			gint key_it = 0;
#line 36 "/home/test/core/core/loggable.vala"
			key_collection = MIDORI_keys;
#line 36 "/home/test/core/core/loggable.vala"
			key_collection_length1 = G_N_ELEMENTS (MIDORI_keys);
#line 36 "/home/test/core/core/loggable.vala"
			for (key_it = 0; key_it < key_collection_length1; key_it = key_it + 1) {
#line 344 "loggable.c"
				GDebugKey key = {0};
#line 36 "/home/test/core/core/loggable.vala"
				key = key_collection[key_it];
#line 348 "loggable.c"
				{
					GDebugKey _tmp3_;
					const gchar* _tmp4_;
					gchar* _tmp5_;
					gchar* _tmp6_;
					gchar* _tmp7_;
					gboolean _tmp8_;
#line 37 "/home/test/core/core/loggable.vala"
					_tmp3_ = key;
#line 37 "/home/test/core/core/loggable.vala"
					_tmp4_ = _tmp3_.key;
#line 37 "/home/test/core/core/loggable.vala"
					_tmp5_ = midori_loggable_get_domain (self);
#line 37 "/home/test/core/core/loggable.vala"
					_tmp6_ = _tmp5_;
#line 37 "/home/test/core/core/loggable.vala"
					_tmp7_ = _tmp6_;
#line 37 "/home/test/core/core/loggable.vala"
					_tmp8_ = g_strcmp0 (_tmp4_, _tmp7_) == 0;
#line 37 "/home/test/core/core/loggable.vala"
					_g_free0 (_tmp7_);
#line 37 "/home/test/core/core/loggable.vala"
					if (_tmp8_) {
#line 372 "loggable.c"
						GDebugKey _tmp9_;
						guint _tmp10_;
#line 38 "/home/test/core/core/loggable.vala"
						_tmp9_ = key;
#line 38 "/home/test/core/core/loggable.vala"
						_tmp10_ = _tmp9_.value;
#line 38 "/home/test/core/core/loggable.vala"
						flag = _tmp10_;
#line 381 "loggable.c"
					}
				}
			}
		}
#line 41 "/home/test/core/core/loggable.vala"
		_tmp11_ = g_getenv ("G_MESSAGES_DEBUG");
#line 41 "/home/test/core/core/loggable.vala"
		_tmp12_ = g_strdup (_tmp11_);
#line 41 "/home/test/core/core/loggable.vala"
		debug_string = _tmp12_;
#line 42 "/home/test/core/core/loggable.vala"
		_tmp13_ = debug_string;
#line 42 "/home/test/core/core/loggable.vala"
		flags = g_parse_debug_string (_tmp13_, MIDORI_keys, G_N_ELEMENTS (MIDORI_keys));
#line 43 "/home/test/core/core/loggable.vala"
		_tmp14_ = flags;
#line 43 "/home/test/core/core/loggable.vala"
		_tmp15_ = flag;
#line 43 "/home/test/core/core/loggable.vala"
		_tmp16_ = (_tmp14_ & _tmp15_) != ((guint) 0);
#line 43 "/home/test/core/core/loggable.vala"
		_tmp17_ = __bool_dup0 (&_tmp16_);
#line 43 "/home/test/core/core/loggable.vala"
		_g_free0 (_logging);
#line 43 "/home/test/core/core/loggable.vala"
		_logging = _tmp17_;
#line 44 "/home/test/core/core/loggable.vala"
		_tmp18_ = _logging;
#line 44 "/home/test/core/core/loggable.vala"
		_tmp19_ = __bool_dup0 (_tmp18_);
#line 44 "/home/test/core/core/loggable.vala"
		g_object_set_data_full ((GObject*) self, "midori-logging", _tmp19_, g_free);
#line 34 "/home/test/core/core/loggable.vala"
		_g_free0 (debug_string);
#line 416 "loggable.c"
	}
#line 46 "/home/test/core/core/loggable.vala"
	_tmp20_ = _logging;
#line 46 "/home/test/core/core/loggable.vala"
	_tmp21_ = *_tmp20_;
#line 46 "/home/test/core/core/loggable.vala"
	_g_free0 (_tmp20_);
#line 46 "/home/test/core/core/loggable.vala"
	result = _tmp21_;
#line 46 "/home/test/core/core/loggable.vala"
	return result;
#line 428 "loggable.c"
}


static void
midori_loggable_default_init (MidoriLoggableIface * iface)
{
}


GType
midori_loggable_get_type (void)
{
	static volatile gsize midori_loggable_type_id__volatile = 0;
	if (g_once_init_enter (&midori_loggable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MidoriLoggableIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) midori_loggable_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType midori_loggable_type_id;
		midori_loggable_type_id = g_type_register_static (G_TYPE_INTERFACE, "MidoriLoggable", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (midori_loggable_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&midori_loggable_type_id__volatile, midori_loggable_type_id);
	}
	return midori_loggable_type_id__volatile;
}



