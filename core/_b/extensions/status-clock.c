/* status-clock.c generated by valac 0.40.23, the Vala compiler
 * generated from status-clock.vala, do not modify */

/*
 Copyright (C) 2010 Arno Renevier <arno@renevier.net>
 Copyright (C) 2018 Christian Dywan <christian@twotoasts.de>

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 See the file COPYING for the full license text.
*/


#include <glib.h>
#include <glib-object.h>
#include "midori-core.h"
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <libpeas/peas.h>


#define STATUS_CLOCK_TYPE_FRONTEND (status_clock_frontend_get_type ())
#define STATUS_CLOCK_FRONTEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontend))
#define STATUS_CLOCK_FRONTEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontendClass))
#define STATUS_CLOCK_IS_FRONTEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), STATUS_CLOCK_TYPE_FRONTEND))
#define STATUS_CLOCK_IS_FRONTEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), STATUS_CLOCK_TYPE_FRONTEND))
#define STATUS_CLOCK_FRONTEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontendClass))

typedef struct _StatusClockFrontend StatusClockFrontend;
typedef struct _StatusClockFrontendClass StatusClockFrontendClass;
typedef struct _StatusClockFrontendPrivate StatusClockFrontendPrivate;
enum  {
	STATUS_CLOCK_FRONTEND_0_PROPERTY,
	STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY,
	STATUS_CLOCK_FRONTEND_NUM_PROPERTIES
};
static GParamSpec* status_clock_frontend_properties[STATUS_CLOCK_FRONTEND_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

struct _StatusClockFrontend {
	GObject parent_instance;
	StatusClockFrontendPrivate * priv;
};

struct _StatusClockFrontendClass {
	GObjectClass parent_class;
};

struct _StatusClockFrontendPrivate {
	MidoriBrowser* _browser;
};

struct _Block1Data {
	int _ref_count_;
	StatusClockFrontend* self;
	GtkLabel* clock;
};

struct _Block2Data {
	int _ref_count_;
	StatusClockFrontend* self;
	GtkLabel* clock;
};


static gpointer status_clock_frontend_parent_class = NULL;
static MidoriBrowserActivatableIface * status_clock_frontend_midori_browser_activatable_parent_iface = NULL;
static GType status_clock_frontend_type_id = 0;

GType status_clock_frontend_register_type (GTypeModule * module);
GType status_clock_frontend_get_type (void) G_GNUC_CONST;
#define STATUS_CLOCK_FRONTEND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontendPrivate))
static gboolean status_clock_frontend_set_current_time (StatusClockFrontend* self,
                                                 GtkLabel* clock);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gsource_func (gpointer self);
static void status_clock_frontend_real_activate (MidoriBrowserActivatable* base);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gboolean __lambda5_ (Block2Data* _data2_,
                     GdkEventCrossing* event);
static gboolean ___lambda5__gtk_widget_enter_notify_event (GtkWidget* _sender,
                                                    GdkEventCrossing* event,
                                                    gpointer self);
static void __lambda6_ (Block2Data* _data2_);
static void ___lambda6__midori_browser_activatable_deactivate (MidoriBrowserActivatable* _sender,
                                                        gpointer self);
StatusClockFrontend* status_clock_frontend_new (void);
StatusClockFrontend* status_clock_frontend_construct (GType object_type);
static void status_clock_frontend_finalize (GObject * obj);
static void _vala_status_clock_frontend_get_property (GObject * object,
                                               guint property_id,
                                               GValue * value,
                                               GParamSpec * pspec);
static void _vala_status_clock_frontend_set_property (GObject * object,
                                               guint property_id,
                                               const GValue * value,
                                               GParamSpec * pspec);
void peas_register_types (GTypeModule* module);
GType status_clock_frontend_register_type (GTypeModule * module);


static gpointer
_g_object_ref0 (gpointer self)
{
#line 17 "/home/test/core/extensions/status-clock.vala"
	return self ? g_object_ref (self) : NULL;
#line 120 "status-clock.c"
}


static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
#line 17 "/home/test/core/extensions/status-clock.vala"
	g_atomic_int_inc (&_data1_->_ref_count_);
#line 17 "/home/test/core/extensions/status-clock.vala"
	return _data1_;
#line 131 "status-clock.c"
}


static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
#line 17 "/home/test/core/extensions/status-clock.vala"
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
#line 142 "status-clock.c"
		StatusClockFrontend* self;
#line 17 "/home/test/core/extensions/status-clock.vala"
		self = _data1_->self;
#line 17 "/home/test/core/extensions/status-clock.vala"
		_g_object_unref0 (_data1_->clock);
#line 17 "/home/test/core/extensions/status-clock.vala"
		_g_object_unref0 (self);
#line 17 "/home/test/core/extensions/status-clock.vala"
		g_slice_free (Block1Data, _data1_);
#line 152 "status-clock.c"
	}
}


static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gboolean result = FALSE;
	gchar* _tmp0_;
#line 1475 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, FALSE);
#line 1475 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	g_return_val_if_fail (needle != NULL, FALSE);
#line 1476 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
#line 1476 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	result = _tmp0_ != NULL;
#line 1476 "/usr/share/vala-0.40/vapi/glib-2.0.vapi"
	return result;
#line 173 "status-clock.c"
}


static gboolean
__lambda4_ (Block1Data* _data1_)
{
	StatusClockFrontend* self;
	gboolean result = FALSE;
#line 22 "/home/test/core/extensions/status-clock.vala"
	self = _data1_->self;
#line 23 "/home/test/core/extensions/status-clock.vala"
	status_clock_frontend_set_current_time (self, _data1_->clock);
#line 24 "/home/test/core/extensions/status-clock.vala"
	result = G_SOURCE_REMOVE;
#line 24 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 190 "status-clock.c"
}


static gboolean
___lambda4__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda4_ (self);
#line 22 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 201 "status-clock.c"
}


static gboolean
status_clock_frontend_set_current_time (StatusClockFrontend* self,
                                        GtkLabel* clock)
{
	gboolean result = FALSE;
	Block1Data* _data1_;
	GtkLabel* _tmp0_;
	GDateTime* date = NULL;
	GDateTime* _tmp1_;
	gchar* format = NULL;
	gchar* _tmp2_;
	GDateTime* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gint _tmp7_ = 0;
	const gchar* _tmp8_;
	gint interval = 0;
#line 17 "/home/test/core/extensions/status-clock.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 17 "/home/test/core/extensions/status-clock.vala"
	g_return_val_if_fail (clock != NULL, FALSE);
#line 17 "/home/test/core/extensions/status-clock.vala"
	_data1_ = g_slice_new0 (Block1Data);
#line 17 "/home/test/core/extensions/status-clock.vala"
	_data1_->_ref_count_ = 1;
#line 17 "/home/test/core/extensions/status-clock.vala"
	_data1_->self = g_object_ref (self);
#line 17 "/home/test/core/extensions/status-clock.vala"
	_tmp0_ = _g_object_ref0 (clock);
#line 17 "/home/test/core/extensions/status-clock.vala"
	_g_object_unref0 (_data1_->clock);
#line 17 "/home/test/core/extensions/status-clock.vala"
	_data1_->clock = _tmp0_;
#line 18 "/home/test/core/extensions/status-clock.vala"
	_tmp1_ = g_date_time_new_now_local ();
#line 18 "/home/test/core/extensions/status-clock.vala"
	date = _tmp1_;
#line 19 "/home/test/core/extensions/status-clock.vala"
	_tmp2_ = g_strdup ("%X");
#line 19 "/home/test/core/extensions/status-clock.vala"
	format = _tmp2_;
#line 20 "/home/test/core/extensions/status-clock.vala"
	_tmp3_ = date;
#line 20 "/home/test/core/extensions/status-clock.vala"
	_tmp4_ = format;
#line 20 "/home/test/core/extensions/status-clock.vala"
	_tmp5_ = g_date_time_format (_tmp3_, _tmp4_);
#line 20 "/home/test/core/extensions/status-clock.vala"
	_tmp6_ = _tmp5_;
#line 20 "/home/test/core/extensions/status-clock.vala"
	gtk_label_set_label (_data1_->clock, _tmp6_);
#line 20 "/home/test/core/extensions/status-clock.vala"
	_g_free0 (_tmp6_);
#line 21 "/home/test/core/extensions/status-clock.vala"
	_tmp8_ = format;
#line 21 "/home/test/core/extensions/status-clock.vala"
	if (string_contains ("%s%N%s%S%T%X", _tmp8_)) {
#line 21 "/home/test/core/extensions/status-clock.vala"
		_tmp7_ = 1;
#line 265 "status-clock.c"
	} else {
		GDateTime* _tmp9_;
#line 21 "/home/test/core/extensions/status-clock.vala"
		_tmp9_ = date;
#line 21 "/home/test/core/extensions/status-clock.vala"
		_tmp7_ = MAX (60 - g_date_time_get_second (_tmp9_), 1);
#line 272 "status-clock.c"
	}
#line 21 "/home/test/core/extensions/status-clock.vala"
	interval = _tmp7_;
#line 22 "/home/test/core/extensions/status-clock.vala"
	g_timeout_add_seconds_full (G_PRIORITY_LOW, (guint) interval, ___lambda4__gsource_func, block1_data_ref (_data1_), block1_data_unref);
#line 26 "/home/test/core/extensions/status-clock.vala"
	result = FALSE;
#line 26 "/home/test/core/extensions/status-clock.vala"
	_g_free0 (format);
#line 26 "/home/test/core/extensions/status-clock.vala"
	_g_date_time_unref0 (date);
#line 26 "/home/test/core/extensions/status-clock.vala"
	block1_data_unref (_data1_);
#line 26 "/home/test/core/extensions/status-clock.vala"
	_data1_ = NULL;
#line 26 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 290 "status-clock.c"
}


static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
#line 29 "/home/test/core/extensions/status-clock.vala"
	g_atomic_int_inc (&_data2_->_ref_count_);
#line 29 "/home/test/core/extensions/status-clock.vala"
	return _data2_;
#line 301 "status-clock.c"
}


static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
#line 29 "/home/test/core/extensions/status-clock.vala"
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
#line 312 "status-clock.c"
		StatusClockFrontend* self;
#line 29 "/home/test/core/extensions/status-clock.vala"
		self = _data2_->self;
#line 29 "/home/test/core/extensions/status-clock.vala"
		_g_object_unref0 (_data2_->clock);
#line 29 "/home/test/core/extensions/status-clock.vala"
		_g_object_unref0 (self);
#line 29 "/home/test/core/extensions/status-clock.vala"
		g_slice_free (Block2Data, _data2_);
#line 322 "status-clock.c"
	}
}


static gboolean
__lambda5_ (Block2Data* _data2_,
            GdkEventCrossing* event)
{
	StatusClockFrontend* self;
	gboolean result = FALSE;
	GtkAlign _tmp0_ = 0;
	GtkAlign _tmp1_;
	GtkAlign _tmp2_;
#line 39 "/home/test/core/extensions/status-clock.vala"
	self = _data2_->self;
#line 39 "/home/test/core/extensions/status-clock.vala"
	g_return_val_if_fail (event != NULL, FALSE);
#line 41 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_hide ((GtkWidget*) _data2_->clock);
#line 42 "/home/test/core/extensions/status-clock.vala"
	_tmp1_ = gtk_widget_get_halign ((GtkWidget*) _data2_->clock);
#line 42 "/home/test/core/extensions/status-clock.vala"
	_tmp2_ = _tmp1_;
#line 42 "/home/test/core/extensions/status-clock.vala"
	if (_tmp2_ == GTK_ALIGN_START) {
#line 42 "/home/test/core/extensions/status-clock.vala"
		_tmp0_ = GTK_ALIGN_END;
#line 350 "status-clock.c"
	} else {
#line 42 "/home/test/core/extensions/status-clock.vala"
		_tmp0_ = GTK_ALIGN_START;
#line 354 "status-clock.c"
	}
#line 42 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_set_halign ((GtkWidget*) _data2_->clock, _tmp0_);
#line 43 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_show ((GtkWidget*) _data2_->clock);
#line 44 "/home/test/core/extensions/status-clock.vala"
	result = FALSE;
#line 44 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 364 "status-clock.c"
}


static gboolean
___lambda5__gtk_widget_enter_notify_event (GtkWidget* _sender,
                                           GdkEventCrossing* event,
                                           gpointer self)
{
	gboolean result;
	result = __lambda5_ (self, event);
#line 39 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 377 "status-clock.c"
}


static void
__lambda6_ (Block2Data* _data2_)
{
	StatusClockFrontend* self;
#line 46 "/home/test/core/extensions/status-clock.vala"
	self = _data2_->self;
#line 47 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_destroy ((GtkWidget*) _data2_->clock);
#line 389 "status-clock.c"
}


static void
___lambda6__midori_browser_activatable_deactivate (MidoriBrowserActivatable* _sender,
                                                   gpointer self)
{
#line 46 "/home/test/core/extensions/status-clock.vala"
	__lambda6_ (self);
#line 399 "status-clock.c"
}


static void
status_clock_frontend_real_activate (MidoriBrowserActivatable* base)
{
	StatusClockFrontend * self;
	Block2Data* _data2_;
	GtkLabel* _tmp0_;
	GtkStyleContext* _tmp1_;
	MidoriBrowser* _tmp2_;
	MidoriBrowser* _tmp3_;
	MidoriBrowser* _tmp4_;
	GtkOverlay* _tmp5_;
	MidoriBrowser* _tmp6_;
	MidoriBrowser* _tmp7_;
	MidoriBrowser* _tmp8_;
	GtkOverlay* _tmp9_;
#line 29 "/home/test/core/extensions/status-clock.vala"
	self = (StatusClockFrontend*) base;
#line 29 "/home/test/core/extensions/status-clock.vala"
	_data2_ = g_slice_new0 (Block2Data);
#line 29 "/home/test/core/extensions/status-clock.vala"
	_data2_->_ref_count_ = 1;
#line 29 "/home/test/core/extensions/status-clock.vala"
	_data2_->self = g_object_ref (self);
#line 30 "/home/test/core/extensions/status-clock.vala"
	_tmp0_ = (GtkLabel*) gtk_label_new ("");
#line 30 "/home/test/core/extensions/status-clock.vala"
	g_object_ref_sink (_tmp0_);
#line 30 "/home/test/core/extensions/status-clock.vala"
	_data2_->clock = _tmp0_;
#line 31 "/home/test/core/extensions/status-clock.vala"
	status_clock_frontend_set_current_time (self, _data2_->clock);
#line 32 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_set_halign ((GtkWidget*) _data2_->clock, GTK_ALIGN_START);
#line 33 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_set_valign ((GtkWidget*) _data2_->clock, GTK_ALIGN_START);
#line 34 "/home/test/core/extensions/status-clock.vala"
	gtk_misc_set_padding ((GtkMisc*) _data2_->clock, 4, 4);
#line 35 "/home/test/core/extensions/status-clock.vala"
	g_object_set ((GtkWidget*) _data2_->clock, "margin", 4, NULL);
#line 36 "/home/test/core/extensions/status-clock.vala"
	_tmp1_ = gtk_widget_get_style_context ((GtkWidget*) _data2_->clock);
#line 36 "/home/test/core/extensions/status-clock.vala"
	gtk_style_context_add_class (_tmp1_, "background");
#line 37 "/home/test/core/extensions/status-clock.vala"
	gtk_widget_show ((GtkWidget*) _data2_->clock);
#line 38 "/home/test/core/extensions/status-clock.vala"
	_tmp2_ = midori_browser_activatable_get_browser ((MidoriBrowserActivatable*) self);
#line 38 "/home/test/core/extensions/status-clock.vala"
	_tmp3_ = _tmp2_;
#line 38 "/home/test/core/extensions/status-clock.vala"
	_tmp4_ = _tmp3_;
#line 38 "/home/test/core/extensions/status-clock.vala"
	_tmp5_ = _tmp4_->overlay;
#line 38 "/home/test/core/extensions/status-clock.vala"
	gtk_overlay_add_overlay (_tmp5_, (GtkWidget*) _data2_->clock);
#line 38 "/home/test/core/extensions/status-clock.vala"
	_g_object_unref0 (_tmp4_);
#line 39 "/home/test/core/extensions/status-clock.vala"
	_tmp6_ = midori_browser_activatable_get_browser ((MidoriBrowserActivatable*) self);
#line 39 "/home/test/core/extensions/status-clock.vala"
	_tmp7_ = _tmp6_;
#line 39 "/home/test/core/extensions/status-clock.vala"
	_tmp8_ = _tmp7_;
#line 39 "/home/test/core/extensions/status-clock.vala"
	_tmp9_ = _tmp8_->overlay;
#line 39 "/home/test/core/extensions/status-clock.vala"
	g_signal_connect_data ((GtkWidget*) _tmp9_, "enter-notify-event", (GCallback) ___lambda5__gtk_widget_enter_notify_event, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
#line 39 "/home/test/core/extensions/status-clock.vala"
	_g_object_unref0 (_tmp8_);
#line 46 "/home/test/core/extensions/status-clock.vala"
	g_signal_connect_data ((MidoriBrowserActivatable*) self, "deactivate", (GCallback) ___lambda6__midori_browser_activatable_deactivate, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
#line 29 "/home/test/core/extensions/status-clock.vala"
	block2_data_unref (_data2_);
#line 29 "/home/test/core/extensions/status-clock.vala"
	_data2_ = NULL;
#line 478 "status-clock.c"
}


StatusClockFrontend*
status_clock_frontend_construct (GType object_type)
{
	StatusClockFrontend * self = NULL;
#line 14 "/home/test/core/extensions/status-clock.vala"
	self = (StatusClockFrontend*) g_object_new (object_type, NULL);
#line 14 "/home/test/core/extensions/status-clock.vala"
	return self;
#line 490 "status-clock.c"
}


StatusClockFrontend*
status_clock_frontend_new (void)
{
#line 14 "/home/test/core/extensions/status-clock.vala"
	return status_clock_frontend_construct (STATUS_CLOCK_TYPE_FRONTEND);
#line 499 "status-clock.c"
}


static MidoriBrowser*
status_clock_frontend_real_get_browser (MidoriBrowserActivatable* base)
{
	MidoriBrowser* result;
	StatusClockFrontend* self;
	MidoriBrowser* _tmp0_;
	MidoriBrowser* _tmp1_;
#line 15 "/home/test/core/extensions/status-clock.vala"
	self = (StatusClockFrontend*) base;
#line 15 "/home/test/core/extensions/status-clock.vala"
	_tmp0_ = self->priv->_browser;
#line 15 "/home/test/core/extensions/status-clock.vala"
	_tmp1_ = _g_object_ref0 (_tmp0_);
#line 15 "/home/test/core/extensions/status-clock.vala"
	result = _tmp1_;
#line 15 "/home/test/core/extensions/status-clock.vala"
	return result;
#line 520 "status-clock.c"
}


static void
status_clock_frontend_real_set_browser (MidoriBrowserActivatable* base,
                                        MidoriBrowser* value)
{
	StatusClockFrontend* self;
#line 15 "/home/test/core/extensions/status-clock.vala"
	self = (StatusClockFrontend*) base;
#line 15 "/home/test/core/extensions/status-clock.vala"
	if (status_clock_frontend_real_get_browser (base) != value) {
#line 533 "status-clock.c"
		MidoriBrowser* _tmp0_;
#line 15 "/home/test/core/extensions/status-clock.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 15 "/home/test/core/extensions/status-clock.vala"
		_g_object_unref0 (self->priv->_browser);
#line 15 "/home/test/core/extensions/status-clock.vala"
		self->priv->_browser = _tmp0_;
#line 15 "/home/test/core/extensions/status-clock.vala"
		g_object_notify_by_pspec ((GObject *) self, status_clock_frontend_properties[STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY]);
#line 543 "status-clock.c"
	}
}


static void
status_clock_frontend_class_init (StatusClockFrontendClass * klass)
{
#line 14 "/home/test/core/extensions/status-clock.vala"
	status_clock_frontend_parent_class = g_type_class_peek_parent (klass);
#line 14 "/home/test/core/extensions/status-clock.vala"
	g_type_class_add_private (klass, sizeof (StatusClockFrontendPrivate));
#line 14 "/home/test/core/extensions/status-clock.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_status_clock_frontend_get_property;
#line 14 "/home/test/core/extensions/status-clock.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_status_clock_frontend_set_property;
#line 14 "/home/test/core/extensions/status-clock.vala"
	G_OBJECT_CLASS (klass)->finalize = status_clock_frontend_finalize;
#line 14 "/home/test/core/extensions/status-clock.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY, status_clock_frontend_properties[STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY] = g_param_spec_object ("browser", "browser", "browser", MIDORI_TYPE_BROWSER, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 563 "status-clock.c"
}


static void
status_clock_frontend_midori_browser_activatable_interface_init (MidoriBrowserActivatableIface * iface)
{
#line 14 "/home/test/core/extensions/status-clock.vala"
	status_clock_frontend_midori_browser_activatable_parent_iface = g_type_interface_peek_parent (iface);
#line 14 "/home/test/core/extensions/status-clock.vala"
	iface->activate = (void (*) (MidoriBrowserActivatable*)) status_clock_frontend_real_activate;
#line 14 "/home/test/core/extensions/status-clock.vala"
	iface->get_browser = status_clock_frontend_real_get_browser;
#line 14 "/home/test/core/extensions/status-clock.vala"
	iface->set_browser = status_clock_frontend_real_set_browser;
#line 578 "status-clock.c"
}


static void
status_clock_frontend_instance_init (StatusClockFrontend * self)
{
#line 14 "/home/test/core/extensions/status-clock.vala"
	self->priv = STATUS_CLOCK_FRONTEND_GET_PRIVATE (self);
#line 587 "status-clock.c"
}


static void
status_clock_frontend_finalize (GObject * obj)
{
	StatusClockFrontend * self;
#line 14 "/home/test/core/extensions/status-clock.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontend);
#line 15 "/home/test/core/extensions/status-clock.vala"
	_g_object_unref0 (self->priv->_browser);
#line 14 "/home/test/core/extensions/status-clock.vala"
	G_OBJECT_CLASS (status_clock_frontend_parent_class)->finalize (obj);
#line 601 "status-clock.c"
}


GType
status_clock_frontend_get_type (void)
{
	return status_clock_frontend_type_id;
}


GType
status_clock_frontend_register_type (GTypeModule * module)
{
	static const GTypeInfo g_define_type_info = { sizeof (StatusClockFrontendClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) status_clock_frontend_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StatusClockFrontend), 0, (GInstanceInitFunc) status_clock_frontend_instance_init, NULL };
	static const GInterfaceInfo midori_browser_activatable_info = { (GInterfaceInitFunc) status_clock_frontend_midori_browser_activatable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	status_clock_frontend_type_id = g_type_module_register_type (module, G_TYPE_OBJECT, "StatusClockFrontend", &g_define_type_info, 0);
	g_type_module_add_interface (module, status_clock_frontend_type_id, MIDORI_TYPE_BROWSER_ACTIVATABLE, &midori_browser_activatable_info);
	return status_clock_frontend_type_id;
}


static void
_vala_status_clock_frontend_get_property (GObject * object,
                                          guint property_id,
                                          GValue * value,
                                          GParamSpec * pspec)
{
	StatusClockFrontend * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontend);
#line 14 "/home/test/core/extensions/status-clock.vala"
	switch (property_id) {
#line 14 "/home/test/core/extensions/status-clock.vala"
		case STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY:
#line 14 "/home/test/core/extensions/status-clock.vala"
		g_value_take_object (value, midori_browser_activatable_get_browser ((MidoriBrowserActivatable*) self));
#line 14 "/home/test/core/extensions/status-clock.vala"
		break;
#line 639 "status-clock.c"
		default:
#line 14 "/home/test/core/extensions/status-clock.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 14 "/home/test/core/extensions/status-clock.vala"
		break;
#line 645 "status-clock.c"
	}
}


static void
_vala_status_clock_frontend_set_property (GObject * object,
                                          guint property_id,
                                          const GValue * value,
                                          GParamSpec * pspec)
{
	StatusClockFrontend * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, STATUS_CLOCK_TYPE_FRONTEND, StatusClockFrontend);
#line 14 "/home/test/core/extensions/status-clock.vala"
	switch (property_id) {
#line 14 "/home/test/core/extensions/status-clock.vala"
		case STATUS_CLOCK_FRONTEND_BROWSER_PROPERTY:
#line 14 "/home/test/core/extensions/status-clock.vala"
		midori_browser_activatable_set_browser ((MidoriBrowserActivatable*) self, g_value_get_object (value));
#line 14 "/home/test/core/extensions/status-clock.vala"
		break;
#line 666 "status-clock.c"
		default:
#line 14 "/home/test/core/extensions/status-clock.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 14 "/home/test/core/extensions/status-clock.vala"
		break;
#line 672 "status-clock.c"
	}
}


void
peas_register_types (GTypeModule* module)
{
#line 54 "/home/test/core/extensions/status-clock.vala"
	g_return_if_fail (module != NULL);
#line 54 "/home/test/core/extensions/status-clock.vala"
	status_clock_frontend_register_type (module);
#line 55 "/home/test/core/extensions/status-clock.vala"
	peas_object_module_register_extension_type (G_TYPE_CHECK_INSTANCE_CAST (module, peas_object_module_get_type (), PeasObjectModule), MIDORI_TYPE_BROWSER_ACTIVATABLE, STATUS_CLOCK_TYPE_FRONTEND);
#line 686 "status-clock.c"
}



